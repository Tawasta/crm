from openerp.osv import osv, fields
from openerp.tools.translate import _
from openerp import SUPERUSER_ID, tools
import re
from datetime import datetime

import logging
_logger = logging.getLogger(__name__)


class crm_claim(osv.Model):

    _inherit = 'crm.claim'

    def create(self, cr, uid, vals, context=None):
        if not context:
            context = {}

        if vals.get('email_from'):
            vals['email_from_readonly'] = vals.get('email_from')

        # If partner doesn't exist, we'll need to create one
        if not vals.get('partner_id'):
            partner_vals = vals.copy()
            partner_vals['claim_autogenerated'] = True
            vals['partner_id'] = self._fetch_partner(
                cr, uid, partner_vals, context=context
            )
        res = super(crm_claim, self).create(cr, uid, vals, context)

        if self.browse(cr, uid, [res], context)[0]:
            fetchmail_server = self.pool.get('fetchmail.server').\
                browse(cr, uid, context.get('fetchmail_server_id'))

            if fetchmail_server:
                company_id = fetchmail_server.company_id.id
                reply_to = self._get_reply_to(cr, uid, company_id=company_id)

                write_vals = {'company_id': company_id, 'reply_to': reply_to,
                              'user_id': False}

                super(crm_claim, self).write(cr, uid, [res], write_vals,
                                             context)

        # Remove the helpdesk email and its aliases from cc emails
        claim_instance = self.browse(cr, uid, res)
        if claim_instance.email_cc:
            email_regex = re.compile("[\w\.-]+@[\w\.-]+")

            email_list = email_regex.findall(claim_instance.email_cc)

            try:
                email_raw = email_regex.findall(claim_instance._get_reply_to())[0]
                email_raw = re.sub(r'[<>]', "", email_raw)

                reply_to = email_raw

                exclude_list = self._get_exclude_list(
                    cr, uid, context, claim_instance.company_id.id
                ) + [reply_to]

                for exclude in exclude_list:
                    match = [s for s in email_list if exclude in s]

                    if match:
                        email_list.pop(email_list.index(match[0]))

                    match = False
                _logger.info("Email CC: %s", email_list)
                email_cc = ','.join(email_list)

                self.write(cr, uid, res, {'email_cc': email_cc})
            except Exception, e:
                _logger.error('Could not set email CC: %s', e)

        if vals.get('attachment_ids'):
            # Update attachment res_id so inline-added
            # attachments are matched correctly
            attachment_obj = self.pool.get('ir.attachment')
            try:
                attachments_list = vals.get('attachment_ids')[0][2]
                for attachment in attachments_list:
                    attachment_obj.write(cr, uid, attachment, {'res_id': res})
            except:
                attachments_list = []

            # Check if attachments are removed
            for attachment_id in attachment_obj.search(
                cr, SUPERUSER_ID, [('res_id', '=', res),
                                   ('res_model', '=', 'crm.claim')]
            ):
                if attachment_id not in attachments_list:
                    attachment_obj.unlink(cr, uid, res)

        return res

    def write(self, cr, uid, ids, values, context=None):
        if values.get('attachment_ids'):
            # Update attachment res_id so inline-added
            # attachments are matched correctly
            attachment_obj = self.pool.get('ir.attachment')
            try:
                attachments_list = values.get('attachment_ids')[0][2]
            except:
                attachments_list = []

            for attachment in attachments_list:
                if not attachment_obj.browse(cr, uid, attachment).res_id:
                    attachment_obj.write(
                        cr, SUPERUSER_ID, attachment,
                        {'res_id': self.browse(cr, uid, ids).id}
                    )

        if values.get('partner_id'):
            # Partner id is changed. Set the new partner as a follower
            self.message_unsubscribe(
                cr, uid, ids, [self.browse(cr, uid, ids).partner_id.id],
                context=context
            )
            self.message_subscribe(
                cr, uid, ids, [values.get('partner_id')], context=context
            )

        return super(crm_claim, self).write(cr, uid, ids, values, context=context)
